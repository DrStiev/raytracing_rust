// HELP: https://github.com/fralken/ray-tracing-in-one-weekend
// https://github.com/lopossumi/Rust-Output-Image
use std::fmt::Write;
use std::fs::File;
use std::io::{self, Write as OtherWrite};
use std::{thread, time};
extern crate termsize;

mod aabb;
mod bvh;
mod camera;
mod color;
mod hittable;
mod logger;
mod material;
mod perlin;
mod progressbar;
mod ray;
mod sphere;
mod texture;
mod util;

// use image;
use image;
use nalgebra::Vector3;
use rand::Rng;
use rayon::prelude::*;
use std::f64;
use std::rc::Rc;

use crate::bvh::BVHNode;
use crate::camera::Camera;
use crate::color::color;
use crate::hittable::{Hittable, HittableList};
use crate::material::{Dielectric, Lambertian, Metal};
use crate::ray::Ray;
use crate::sphere::{MovingSphere, Sphere};
use crate::texture::{CheckerTexture, ImageTexture, NoiseTexture, SolidTexture};
use crate::util::{random_in_unit_disk, random_in_unit_sphere};
use crate::{logger::*, progressbar::*, LogLevel::*};

// #[cfg(test)]
mod test;
use crate::test::{earth, random_scene, set_camera, two_perlin_sphere, two_spheres};

// cargo run > image.ppm

fn main() {
    // let total_steps: usize = 100; // this value is used to set the size of the pb and to make it display gracefully
    // progressbar(total_steps, "RAY TRACING IN ONE WEEK WITH RUST");

    let mut rng = rand::thread_rng();

    // set logger
    let mut l = Logger::new();
    l.set_level(INFO);
    l.set_description("START WORKING WITH RAYTRACING AND RUST!");
    let _ = l.write_to_file("log.log");

    let path = [
        "output/random_spheres.ppm",
        "output/two_spheres.ppm",
        "output/two_perlin_spheres.ppm",
        "output/earth.ppm",
    ];

    for i in 0..path.len() {
        // create  file
        let mut file = File::create(path[i]).expect("REASON");

        l.set_level(DEBUG);
        l.set_description(&format!("Rendering scene: {}", path[i]));
        let _ = l.write_to_file("log.log");

        // set camera
        let ns = 100;
        let nx = 1280;
        let ny = 720;

        l.set_level(DEBUG);
        l.set_description("Initialize Camera");
        let _ = l.write_to_file("log.log");

        let cam = set_camera(
            nx,
            ny,
            Vector3::new(13.0, 2.0, 3.0),
            Vector3::new(0.0, 0.0, 0.0),
            Vector3::new(0.0, 1.0, 0.0),
            20.0,
            10.0,
            0.1,
            0.0,
            1.0,
        );

        l.set_level(DEBUG);
        l.set_description("Initialize Scene (or World)");
        let _ = l.write_to_file("log.log");

        // chose which image to render
        let world = match i {
            0 => random_scene(),
            1 => two_spheres(),
            2 => two_perlin_sphere(),
            3 => earth(),
            _ => random_scene(), // default case
        };

        // create the image
        l.set_level(DEBUG);
        l.set_description("Create Image");
        let _ = l.write_to_file("log.log");

        let mut output = String::new();
        write!(output, "P3\n{} {}\n255\n", nx, ny).unwrap();
        // println!("P3\n{} {}\n255", nx, ny);

        for j in (0..ny).rev() {
            for i in 0..nx {
                let mut col = Vector3::new(0.0, 0.0, 0.0);
                for _ in 0..ns {
                    let u = (i as f64 + rng.gen::<f64>()) / nx as f64;
                    let v = (j as f64 + rng.gen::<f64>()) / ny as f64;
                    let ray = cam.get_ray(u, v);
                    col += color(&ray, &world, 0);
                }
                col /= ns as f64;
                for c in col.iter_mut() {
                    *c = c.sqrt();
                }
                let ir = (255.99 * col[0]) as i32;
                let ig = (255.99 * col[1]) as i32;
                let ib = (255.99 * col[2]) as i32;
                write!(output, "{} {} {}", ir, ig, ib).unwrap();
                // println!("{} {} {}", ir, ig, ib);
            }
        }

        // write content into file
        write!(file, "{}", output).expect("REASON");

        l.set_level(INFO);
        l.set_description("END WORKING WITH RAYTRACING AND RUST!\n");
        let _ = l.write_to_file("log.log");
    }

    // USE OF RAYON. NOT CONVINCING RIGHT NOW
    // // create the image
    // l.set_level(DEBUG);
    // l.set_description("Create Image exploiting parallelization with rayon");
    // let _ = l.write_to_file("log.log");
    // let image = (0..ny)
    //     .into_par_iter()
    //     .rev()
    //     .flat_map(|y| {
    //         (0..nx)
    //             .flat_map(|x| {
    //                 let col: Vector3<f64> = (0..ns)
    //                     .map(|_| {
    //                         let mut rng = rand::thread_rng();
    //                         let u = (x as f64 + rng.gen::<f64>()) / nx as f64;
    //                         let v = (y as f64 + rng.gen::<f64>()) / ny as f64;
    //                         let ray = cam.get_ray(u, v);
    //                         color(&ray, &world, 0)
    //                     })
    //                     .sum();
    //                 col.iter()
    //                     .map(|c| (255.99 * (c / ns as f64).sqrt().max(0.0).min(1.0)) as u8)
    //                     .collect::<Vec<u8>>()
    //             })
    //             .collect::<Vec<u8>>()
    //     })
    //     .collect::<Vec<u8>>();

    // // save the image to file
    // l.set_level(DEBUG);
    // l.set_description("Save image into a .ppm file");
    // let _ = l.write_to_file("log.log");
    // for col in image.chunks(3) {
    //     println!("{} {} {}", col[0], col[1], col[2]);
    // }
}
